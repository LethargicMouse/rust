extern read: fn(i32, *u8, u64) u64;
extern write: fn(i32, cstr, u64) u64;


fn main(len: i32, buf: *cstr) {
  "your mom".words()[0].putstr();
}

fn words(str) arr<str> {
  let left = 0;
  let right = 1;
  let result = empty_vec();
  loop {
    if (right == str.len) return result;
    if (str.buf[right] == space) {
      result.push(str.substr(left, right));
      left = right + 1;
    }
    right = right + 1;
  }
}

fn push<t>(vec<t>, t) {
  if (vec.len == vec.cap) vec.grow();
  vec.buf[vec.len] = t;
  vec.len = vec.len + 1;
}

fn grow<t>(vec<t>) {
  if (vec.cap == 0) {
    vec.cap = 8;
    vec.buf = malloc(8 * @size t);
  } else {
    let new_cap = vec.cap * 2;
    vec.buf = realloc(vec.buf, vec.cap, new_cap);
    vec.cap = new_cap;
  }
}

type args = arr<cstr>;

fn substr(str, left: index, right: index) str {
  str {
    buf: str.buf + left,
    len: right - left
  }
}

type index = size;
type size = u64;

fn putiln(i64) {
  puti(i64);
  putstr("\n")
}

fn putstr(str) {
  write(1, str.buf, str.len);
}

fn puti(i64) {
  if (i64 == 0) putstr("0")
  else puti_not_0(i64)
}

fn puti_not_0(i64) {
  if (i64 == 0) return;
  puti_not_0(i64 / 10);
  putc((47 + i64 % 10) as u8)
}

fn putc(u8) {
  write(1, &u8, 1);
}

type str = slice<u8>;
type cstr = *u8;

struct arr<t> {
  buf: *t,
  len: u64
}

