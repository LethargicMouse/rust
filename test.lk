extern strcmp: fn(*u8, *u8) bool;
extern system: fn(*u8);
extern puts: fn(*u8);
extern exit: fn(i32);
extern fopen: fn(*u8, *u8) *();
extern fwrite: fn(*u8, u64, u64, *()) u64;
extern fclose: fn(*());

fn main(argc: i32, argv: **u8) {
    if argc < 2
      do die(r"! error reading args: expected command");
    if strcmp(argv[1], r"clean") == 0
      do clean()
    else if strcmp(argv[1], r"run") == 0 {
        if argc < 3
          do die(r"! error reading args: expected path")
        else run(argv[2])
      }
    else puts(r"! error reading args: unexpected command");
  }

fn die(e: *u8) {
    puts(e);
    exit(1)
  }

fn clean()
  do system(r"rm out.qbe out.s out")

fn run(path: *u8) {
    clean();
    build(path);
    system(r"./out || echo fail")
  }

fn build(path: *u8) {
    compile(path).dump();
    postcompile();
  }

fn compile(path: *u8) ir 
  do path
    .read()
    .lex()
    .parse()
    .analyse()
    .generate()

fn read(path: *u8) source {
    new source {}
  }

fn lex(source) vec_token {
    new vec_token {}
  }

struct source {}

fn parse(tokens: vec_token) ast {
    new ast {}
  }

struct vec_token {}

fn analyse(ast) asg {
    init_analyse().run_analyse(ast)
  }

fn init_analyse() analyse {
    new analyse {}
  }

fn run_analyse(self: analyse, ast) asg {
    self.ast_structs = ast.structs;
    new asg {}
  }

struct ast {
    structs: hash_map
  }

fn generate(asg) ir {
    new ir {}
  }

struct analyse {
    ast_structs: hash_map
  }

struct asg {}

fn dump(ir) {
    let out = fopen(r"out.qbe", r"w");
    putstr(out, "export function w $main() {\n@start\nret 123\n}");
    fclose(out);
  }

struct ir {}

fn putstr(file: *(), str) {
    fwrite(str.ptr, 1, str.len, file);
  }

struct str {
    ptr: *u8,
    len: u64,
  }

fn postcompile() 
  do system(r"qbe -o out.s out.qbe && cc -o out out.s")

struct hash_map {}
