extern strcmp: fn(*u8, *u8) bool;
extern system: fn(*u8);
extern puts: fn(*u8);
extern exit: fn(i32);
extern fopen: fn(*u8, *u8);
extern fwrite: fn(*u8, u64, u64, *FILE) u64;
extern fclose: fn(*FILE);

fn main(argc, argv: **u8) {
    if argc < 2
      do die(r"! error reading args: expected command");
    if strcmp(argv[1], r"clean") == 0
      do clean()
    else if strcmp(argv[1], r"run") == 0 {
        if argc < 3
          do die(r"! error reading args: expected path")
        else run(argv[2])
      }
    else puts(r"! error reading args: unexpected command");
  }

fn die(e) {
    puts(e);
    exit(1)
  }

fn clean()
  do system(r"rm out.qbe out.s out")

fn run(path) {
    clean();
    build(path);
    system(r"./out")
  }

fn build(path) {
    compile(path).dump();
    postcompile();
  }

fn compile(path) 
  do path
    .read()
    .lex()
    .parse()
    .analyse()
    .generate()

fn read(path) {
    
  }

fn lex(code) {
    
  }

fn parse(tokens) {

  }

fn analyse(ast) {

  }

fn generate(asg) {
    
  }

fn dump(ir) {
    let out = fopen(r"out.qbe", r"w");
    putstr(out, "test drive");
    fclose(out);
  }

fn putstr(file, str) {
    fwrite(str.ptr, 1, str.len, file)
  }

struct str {

  }

fn postcompile() 
  do system(r"qbe -o out.s out.qbe && cc -o out out.s")
