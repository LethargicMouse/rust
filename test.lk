extern strcmp: fn(*u8, *u8) bool;
extern system: fn(*u8);
extern puts: fn(*u8);
extern exit: fn(i32);
extern open: fn(*u8, *u8) i32;
extern write: fn(i32, *u8, u64) u64;
extern close: fn(i32);

fn main(argc: i32, argv: **u8) {
    if argc < 2
      do die(r"! error reading args: expected command");
    if strcmp(argv[1], r"clean") == 0
      do clean()
    else if strcmp(argv[1], r"run") == 0 {
        if argc < 3
          do die(r"! error reading args: expected path")
        else run(argv[2])
      }
    else puts(r"! error reading args: unexpected command");
  }

fn die(e: *u8) {
    puts(e);
    exit(1)
  }

fn clean()
  do system(r"rm out.qbe out.s out")

fn run(path: *u8) {
    clean();
    build(path);
    system(r"./out")
  }

fn build(path: *u8) {
    compile(path).dump();
    postcompile();
  }

fn compile(path: *u8) 
  do path
    .read()
    .lex()
    .parse()
    .analyse()
    .generate()

fn read(path: *u8) {
    
  }

fn lex(source) {
    
  }

struct source {}

fn parse(tokens: vec_token) {

  }

struct vec_token {}

fn analyse(ast) {

  }

struct ast {}

fn generate(asg) {
    
  }

struct asg {}

fn dump(ir) {
    let out = open(r"out.qbe", r"w");
    putstr(out, "test drive");
    close(out);
  }

struct ir {}

fn putstr(file: i32, str) {
    write(file, str.ptr, str.len)
  }

struct str {
    len: u64,
    ptr: *u8
  }

fn postcompile() 
  do system(r"qbe -o out.s out.qbe && cc -o out out.s")
