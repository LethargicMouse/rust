extern fn InitWindow(i32, i32, cstr);
extern fn SetTargetFPS(i32);
extern fn WindowShouldClose() bool;
extern fn CloseWindow();
extern fn BeginDrawing();
extern fn ClearBackground(color);
extern fn DrawText(cstr, i32, i32, i32, color);
extern fn EndDrawing();
extern fn MeasureText(cstr, i32) i32;
extern fn GetFrameTime() f32;
extern fn sin(f64) f64;
extern fn cos(f64) f64;
extern fn write(fd, *u8, size);
extern fn DrawCircle(i32, i32, f32, color);
extern fn IsKeyPressed(u8) bool;
extern fn GetKeyPressed() u8;

struct arr<t> {
  ptr: *t,
  len: size
}

type size = u64;

type cstr = *u8;

struct color { r: u8, g: u8, b: u8, a: u8 }

let black: color = color {r: 0, g: 0, b: 0, a: 255};
let lightgray: color = color {r: 200, g: 200, b: 200, a: 255};
let blue: color = color {r: 102, g: 191, b: 255, a: 255};
let yellow: color = color {r: 253, g: 249, b: 0, a: 255};

fn main() {
  init();
  loop {
    if should_close 
      do break;
    draw();
    update();
  }
  deinit();
}

impl display for bool {
  fn wprint<w: writer>(w, self)
    do if self
      do w.wprint("true")
    else w.wprint("false")
}

let should_close: bool = false;
let pipe_timer: f32 = 0;

fn update() {
  if check_if_should_close()
    do return;
  update_pipes();
  update_bird();
}

let pipe_period: f32 = 0;

fn update_pipes() {
  pipe_timer += GetFrameTime();
  if pipe_timer > pipe_period {
    pipe_timer = 0;
    pipes.push(width);
  }
}

fn push<t>(&vec<t>, t) {
  if (vec.size == vec.buf.size)
    do vec.buf.grow();
  vec.buf.ptr[vec.size] = t;
  vec.size += 1;
}

let jump_speed: f32 = 300;
let g: f32 = 700;
let v: f32 = 0;
let y: f32 = 0;

fn update_bird() {
  let dt = GetFrameTime();
  y += v * dt;
  v += g * dt;
  if IsKeyPressed(' ')
    do v = -jump_speed;
}

impl display for u8 {
  fn wprint<w: writer>(w, self)
    do w.wprint(self as i64)
}

impl display for i64 {
  fn wprint<w: writer>(w, self)
    do if self == 0
      do w.wprint("0")
    else w.wprint(non_null {i64: self})
}

struct non_null {i64}

fn non_null(i64) non_null
  do non_null {i64}

impl display for non_null {
  fn wprint<w: writer>(w, self) {
    if self.i64 == 0
      do return;
    let c = (48 + self.i64 % 10) as u8;
    w.wprint(non_null(self.i64 / 10));
    w.wprint(c2str(c));
  }
}

fn c2str(&u8) str
  do str {
    ptr: u8 as *u8,
    len: 1
  }

fn eprint<s: display>(s) 
  do stderr.wprint(s)

let stderr: file = file {fd: 2};

struct file {fd}

type fd = i32;

trait display {
  fn wprint<w: writer>(w, self);
}

trait writer {
  fn wwrite(self, str);
}

type str = arr<u8>;

impl writer for file {
  fn wwrite(self, str)
    do write(self.fd, str.ptr, str.len)
}

fn eprintln<s: display>(s) {
  eprint(s);
  eprint("\n")
}

impl display for str {
  fn wprint<w: writer>(w, self)
    do w.wwrite(self)
}

fn check_if_should_close() bool
  do should_close = WindowShouldClose() | IsKeyPressed('Q')

let width: i32 = 800;
let height: i32 = 600;

fn init() {
  InitWindow(width, height, "test window".ptr);
  SetTargetFPS(60);
}

fn deinit() {
  CloseWindow();
}

let pipes: vec<i32> = vec {
  buf: arr {ptr: 0, size: 0},
  size: 0
};

struct vec<t> {
  buf: arr<t>,
  size
}

fn draw() {
  BeginDrawing();
  ClearBackground(black);
  draw_bird();
  EndDrawing();
}

let bird_r: f32 = 20;

fn draw_bird()
  do DrawCircle(width / 6, height / 2 + y as i32, bird_r, yellow);
